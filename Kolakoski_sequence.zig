// https://rosettacode.org/wiki/Kolakoski_sequence
// {{works with|Zig|0.15.1}}
// {{trans|Go}}
const std = @import("std");

pub fn main() !void {
    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout = &stdout_writer.interface;

    var gpa: std.heap.DebugAllocator(.{}) = .init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const ias = [4][]const usize{
        &[_]usize{ 1, 2 },
        &[_]usize{ 2, 1 },
        &[_]usize{ 1, 3, 1, 2 },
        &[_]usize{ 1, 3, 2, 1 },
    };
    const slens = [ias.len]usize{ 20, 20, 30, 30 };
    for (ias, slens) |ia, slen| {
        const kol = try kolakoski(allocator, ia, slen);
        defer allocator.free(kol);
        try stdout.print("First {d} members of the sequence generated by: {any}\n", .{ slen, ia });
        try stdout.print("{any}\n", .{kol});
        const p = try isPossibleKolakoski(allocator, kol);
        const poss: []const u8 = if (p) "Yes" else "No";
        try stdout.print("Possible Kolakoski sequence? {s}\n\n", .{poss});
    }

    try stdout.flush();
}

/// Allocates memory for the result, which must be freed by the caller.
fn kolakoski(allocator: std.mem.Allocator, cycle: []const usize, slen: usize) ![]usize {
    const sequence = try allocator.alloc(usize, slen);
    var i: usize = 0;
    var k: usize = 0;
    while (true) {
        sequence[i] = nextInCycle(cycle, k);
        if (sequence[k] > 1) {
            var j: usize = 1;
            while (j < sequence[k]) : (j += 1) {
                i += 1;
                if (i == slen)
                    return sequence;
                sequence[i] = sequence[i - 1];
            }
        }
        i += 1;
        if (i == slen)
            return sequence;
        k += 1;
    }
}
fn nextInCycle(cycle: []const usize, index: usize) usize {
    return cycle[index % cycle.len];
}
fn isPossibleKolakoski(allocator: std.mem.Allocator, sequence: []usize) !bool {
    var rle: std.ArrayList(usize) = .empty;
    defer rle.deinit(allocator);
    var prev = sequence[0];
    var count: usize = 1;
    for (sequence[1..sequence.len]) |n| {
        if (n == prev)
            count += 1
        else {
            try rle.append(allocator, count);
            count = 1;
            prev = n;
        }
    }
    // no point adding final 'count' to rle as we're not going to compare it anyway
    for (rle.items, sequence[0..rle.items.len]) |a, b|
        if (a != b)
            return false;
    return true;
}
